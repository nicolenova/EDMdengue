---
title: "Convergent Cross-Mapping (Figure 3)"   
author:  | 
  | Nicole Nova, Ethan R. Deyle, Marta S. Shocket, Andrew J. MacDonald, Marissa L. Childs, Martin Rypdal, George Sugihara, and Erin A. Mordecai
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

## Convergent Cross-Mapping (Figure 3)

If necessary, we can clear the environment to start with a clean workspace.
```{r}
rm(list=ls())
```

Help functions.
```{r}
source("data_formatting.R")
source("ccm_functions.R")
```

Here, we can load previous results.
```{r}
#load(file="../cache/Figure_3.RData")
#load(file="../cache/CCM_null_seasonal.RData")
```


### Data

We load and process the data and create our main dataframe PR, which stands for "Puerto Rico."
```{r}
PR <- data.clean("combined_SanJuan_PuertoRico_1990-2009")
```

Add lagged and averaged lagged variables.
```{r}
PR <- data.process(PR)
```

Normalize the variables before performing EDM analyses.
```{r}
# Normalize the whole dataset
PR.norm <- scale(PR[,c(-1,-2)], center = TRUE, scale = TRUE)

# Convert back to dataframe
PR.norm <- as.data.frame(PR.norm)

# Add the date back
PR.norm <- cbind(PR[1], PR[2], PR.norm)

# Renaming PR to PR.norm since that's what we'll be using in the next EDM analyses
PR.orig <- PR
PR <- PR.norm
```

Oprimal embedding dimensions from Figure S3.
```{r}
# Optimal E
E_cases = 8
E_temp = 8
E_prec = 6
E_mu = 5
```


### Convergent Cross-Mapping (CCM)

Run CCM between cases and each driver.
```{r}
PR.lag <- PR[, c("cases", "temp.lag_9", "prec.avglag_3", "mu.lag_5")]

PR <- PR.lag

names(PR) <- c("cases", "temp", "prec", "mu")

# Remove rows with NA
PR2 <- PR[18:987,]

PR <- PR2
```

```{r}
# Design a sequence of library size libs
libs <- c(seq(10, 70, 20), seq(100, 400, 100))
num_sur <- 500 # Number of surrogates used
bootrun <- 500 # Number of bootstrap runs (number of samples for each library size)
```

```{r}
Tau <- 1
TP <- 0
excl_rad <- NULL
```

CCM using the actual data.
```{r}
for (i in 2:4) {
  # For Figure S7
  # driver xmap cases 
  # CCM analysis with varying library size (L)
  driver_xmap_cases <- ccm(PR, E = get(paste("E_", names(PR[i]), sep="")), 
                         lib_column = names(PR[i]), target_column = "cases", 
                         lib_sizes = libs, RNGseed = 2301, random_libs = T, replace = F,
                         num_samples = bootrun,
                         tau = Tau, exclusion_radius = excl_rad, tp = TP)
  assign(paste(names(PR[i]), "_xmap_cases", sep=""), driver_xmap_cases)
  
  # Calculate the median, maximum, and upper and lower quantiles of rho for each L
  driver_cases_q = as.matrix(aggregate(driver_xmap_cases[,c('rho')], 
                                    by = list(as.factor(driver_xmap_cases$lib_size)), 
                                    function (x) quantile(x, c(0.025, 0.5, 0.975))
                                    )[,'x']
                          ) 
  # Kendall test
  MK <- apply(driver_cases_q, 2, MannKendall)
  assign(paste(names(PR[i]), "_cases_q", sep=""), driver_cases_q)
  assign(paste(names(PR[i]), "_cases_MK", sep=""), MK)
}
save.image(file="../cache/CCM.RData") 


for (i in 2:4) {
  # For Figure 3
  # cases xmap driver
  # CCM analysis with varying library size (L)
  cases_xmap_driver <- ccm(PR, E = E_cases, lib_column = "cases", target_column = names(PR[i]), 
                         lib_sizes = libs, RNGseed = 2301, random_libs = T, replace = F,
                         num_samples = bootrun,
                         tau = Tau, exclusion_radius = excl_rad, tp = TP)
  assign(paste("cases_xmap_", names(PR[i]), sep=""), cases_xmap_driver)
  
  # Calculate the median, maximum, and upper and lower quantiles of rho for each L
  cases_driver_q = as.matrix(aggregate(cases_xmap_driver[,c('rho')], 
                                    by = list(as.factor(cases_xmap_driver$lib_size)), 
                                    function (x) quantile(x, c(0.025, 0.5, 0.975))
                                    )[,'x']
                          ) 
  # Kendall test
  MK <- apply(cases_driver_q, 2, MannKendall)
  assign(paste("cases_", names(PR[i]), "_q", sep=""), cases_driver_q)
  assign(paste("cases_", names(PR[i]), "_MK", sep=""), MK)
}

save.image(file="../cache/CCM.RData")
```


### Figure 3

CCM to obtain null distributions.
```{r}
getCCMresults("seasonal", 52)
```

Plot all subplots.
```{r}
plot.ccm("fig_3")
```


### Kolmogorov-Smirnov test

Compare the distributions of the prediction skill generated by the null and that of the actual variables in CCM. This is to obtain a p-value to see whether the performance of the driver is distinguishable from the null. We compare distributions generated right after or close to convergence, so around the time series length of 100 weeks (Figure 3 and S8). We use the nonparametric K-S tests because the two distributions are not necessarily normal and they might have different variances.
```{r}
# For Figure 3 when using seasonal null
ks.results("temp")
ks.results("prec")  # Significant
ks.results("mu")    # Significant
```

Here, we can save our progress.
```{r}
save.image(file="../cache/Figure_3.RData") 
```